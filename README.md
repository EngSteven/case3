# case 3 Explicación 

Ejercicio #1: 
- Se recibe una expresión en notación infija de tipo string, la cual es enviada al método toPosfijo quien se encarga de transformar la expresión en notación postfija que se guarda en una pila de tipo string. Este método de conversión, lo que hace es crear primero dos listas, 1 que almacena las operaciones y otra de salida que almacena los números y operaciones en la notación requerida. Se recorre toda la expresión enviada, y mediante el switch se va evaluando caracter por caracter, aplicando las reglas de la conversión según la precedencia. Luego de optener todos los caracteres en la pila de salida, esta se retorna y se le da vuelta al resultado para enviarlo a método evaluation que retorna un int. Este método de evaluación recibe una expresión infija, y lo que hace es ir recorriendo dicha expresión hasta que este vacía. De igual forma, con el uso del swicth se evalua cual caracter es el actual, de modo que si son números los añade con el default, y si es una operación, lo que hace es darle un número, de modo que si es una suma la operación contiene el 1 y así con las demás, de modo que cuando se salga del switch, evalua cual operación es la actual, y la ejecuta mediante el método calculateResult, que recibe los dos últimos  números dados, y hace la operación actual, ese resultado se guarda en la lista de operations para que siga siendo evaluado hasta el final y se retorna el resultado total de la expresión.

Ejercicio #2:
- Este ejercicio se enfoca en usar las 2 pilas de forma que simulen el funcionamiento de las colas. Para el método enqueue y isEmpty no se hacen cambios, porque al fin y al cabo queremos que nos devuelva los datos como lo hace una cola. Por esa razón, se cambia el método dequeue, en donde creamos una variable para almacenar el resultado del dequeue a retornar y eliminar, y un current que nos ayude a almacenar cada nodo de las pilas. Entonce, con un while se van sacando todos los nodos de la pila 1, quien es la que los almacena, y se van guardando en la pila 2, de modo que el nodo que esta en la última posición pase a ser el que este en la primer posición y así se van rotando todos hasta llegar al segundo nodo, ya que este es que debe quedar en la última posición, porque el primer nodo es que se tiene que eliminar y retornar, como una cola corriente, y para lograr llegar a este, debemos recorrer toda la pila, entonces se almacena este nodo que esta en la primer posición en result, por último, se devuelven todos los nodos tal y como estaban al princio en la pila 1, y se retorna el nodo que se guardo en result. 
- El método front aplica exactamente la misma lógica que el dequeue, solo que al llegar a encontrar el nodo de la primer posición, se hace un top, para que el nodo no se elimine, sino que solo sea retornado, y al final si sale toda la pila tal y como estaba, junto con el nodo que se encuentre en la primer posición y se retorna el result que almacena dicho primer nodo.

Ejercicio #3
- Lo primero que se hace es definir los datos, cuantos vuelos van a ver, intervalos de las horas de minima y max. Luego se llena la lista de vuelos, mediante el uso de rands, que van a dar horas de vuelos aleatorios según los intervalos definidos, y además se genera un rand con respecto a los minutos de atraso y se le suman a la hora total. Luego de contener todos los vuelos randoms, se hace uso del método fillTracks, el cual va a recibir dicha lista de vuelos, y además las listas de colas con prioridad.
- La prioridad se obtiene con el método getIntTimeValue, el cual retorna la hora ingresada de un vuelo dado en segundos, y esa es la prioridad que se usa para cada vuelo.
- Las colas con prioridad se implementaron con el uso de los métodos ya implimentados en las listas, de modo que si la prioridad es mayor que las demás se usa addBehin para insertarla al principio, si es menor que las demás se usa add para añadirla al final y se no es niguna de estas dos últimas, se empieza a buscar las prioridades para ver en cual insertarla, al encontrarla se usa el insert con la posición encontrada y se inserta.
- Fill tracks, lo que hace es ir llenando cada lista de track, de modo le hace 1 push a cada track, por cada iteración, para que queden repartidas y se vayan ordenando según su prioridad.
- Luego, mediante la clase Airport, se usa el método releaseFlights, la cual recibe las tracks ya llenadas, evalua el orden de salida. Dicho algoritmo lo que hace es hacer un for del largo de la cantida de vuelos, en donde va evaluando cual es la prioridad máxima, esta prioridad siempre se encuentra en la primer posicion de alguna de las tracks, ya que la cola de prioridad las ordena. Entonces al encontrar la prioridad mayor, empieza a evaluar cuales vuelos tienen esa prioridad mayor y va imprimiendo los vuelos que la tengan. Pero de igual forma, dicha prioridad, si bien es cierto que se puede encontrar en posiciones diferentes a la primera de alguna de las tracks, no las tomaría en cuenta en la iteración actual, debido a que los aviones no pueden salir al mismo tiempo por la misma track, por eso solo evalua las primeras posiciones de las tracks por iteración.

